/*
This code written by Joiah Hester and Modified by Arwa Alsubhi.
To run this code make sure you have GSL (GNU Scientific Library) installed in your machine
$ brew install Gsl
Two files will be generated by executing this code: *.ivs (has all IV curves) and *.raw (has raw data (voltage,current) pair)
*/
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>
#include <gsl/gsl_multifit.h>

//////////////// header file to get elapsed time for diffrents OS
#if defined(_WIN32)
#include <Windows.h>
#elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__))
#include <unistd.h>   /* POSIX flags */
#include <time.h>	 /* clock_gettime(), time() */
#include <sys/time.h> /* gethrtime(), gettimeofday() */
#if defined(__MACH__) && defined(__APPLE__)
#include <mach/mach.h>
#include <mach/mach_time.h>
#endif
#else
#error "Unable to define getRealTime( ) for an unknown OS."
#endif
/////////////////////////////////////////////////////////////////
#define COUNT 500
#define ALL_CURVES_LEN 100
#define NUMPOINTS 65
#define DEGREE 5

int tempint;
int numcurves = 0;
int cpsavg = 0;
long double coeff[DEGREE];
long double allcurves[ALL_CURVES_LEN][NUMPOINTS];
long double curvedata[2][COUNT];
int indexInAllCurves = 0;

char input_file_name[255];
char gnu_file_name[255];
char ivs_file_name[255];

FILE *infile, *gnu_outfile, *ivs_outfile;

long double VOLTAGES[NUMPOINTS] = {0, 0.16615384615, 0.33230769230, 0.49846153845, 0.66461538460, 0.83076923075, 0.99692307690, 1.16307692305, 1.32923076920, 1.49538461535, 1.66153846150, 1.82769230765, 1.99384615380, 2.15999999995, 2.32615384610, 2.49230769225, 2.65846153840, 2.82461538455, 2.99076923070, 3.15692307685, 3.32307692300, 3.48923076915, 3.65538461530, 3.82153846145, 3.98769230760, 4.15384615375, 4.31999999990, 4.48615384605, 4.65230769220, 4.81846153835, 4.98461538450, 5.15076923065, 5.31692307680, 5.48307692295, 5.64923076910, 5.81538461525, 5.98153846140, 6.14769230755, 6.31384615370, 6.47999999985, 6.64615384600, 6.81230769215, 6.97846153830, 7.14461538445, 7.31076923060, 7.47692307675, 7.64307692290, 7.80923076905, 7.97538461520, 8.14153846135, 8.30769230750, 8.47384615365, 8.63999999980, 8.80615384595, 8.97230769210, 9.13846153825, 9.30461538440, 9.47076923055, 9.63692307670, 9.80307692285, 9.96923076900, 10.13538461515, 10.30153846130, 10.46769230745, 10.63384615360};
/*  Where are these values come from ?
   10.8 volts is max voltage range can be produced by the emulator board and we have 65 points on x axis (voltage).
	 so 10.8/65 = 0.16615384615L. to get all 65 points value on x axis, 0.16615384615 is added to get next point on the axis.
    long double v=0;
   for (int j=1;j<65;j++)
   {
       v+=0.16615384615L; // 10.8(max voltage range)/65points
   }
*/

void create_curves_with_regression(void);
struct current
{
	int raw_value;
	int gain;
};

struct current get_current(int current1, int current2, int current3);

#define READSIZE 12 // read 12 bytes from serial ports
#define BUFSIZE 1024
#define SENSE_Resistor 10				// 10 Ohms sense resistor on Ekho board
#define ADC_to_Voltage 0.0008056640625L // = 3.3/2^12
#define Current1_gain 11				//the none-inverting opamplifier gain for current 1 on Ehko board
#define Current2_gain 121				// the none-inverting opamplifier gain for current 2 on Ehko board
#define Current3_gain 1331				// the none-inverting opamplifier gain for current 3 on Ehko board
#define Voltage_gain 2					// the none-inverting opamplifier gain for voltage on Ehko board
#define VREF_ADC 1118

#define SATURATION_THRESHOLD 4030
#define NUMPOINTS 65

int port;
int count = 0;
double getRealTime(void);

/* Serial init and configuration */
void init_serial(int argc, char **argv)
{
	struct termios settings;
	// Open the serial port
	port = open(argv[1], O_RDWR);
	if (port < 0)
	{
		fprintf(stderr, "Unable to open %s\n", argv[1]);
		exit(0);
	}

	// Configure the port
	tcgetattr(port, &settings);
	cfmakeraw(&settings);
	tcsetattr(port, TCSANOW, &settings);
}

/////////////////////////////
void convert_data()
{
	int n;
	int points = 0;
	double timestamp;

	while (1)
	{

		//Binary file
		points = 499;
		n = fread(&timestamp, sizeof(double), 1, infile);
		// read from file all x points (voltages)
		n = fread(curvedata[0], sizeof(long double), COUNT, infile);
		// read from file all y points (currents)
		n = fread(curvedata[1], sizeof(long double), COUNT, infile);

		//text readable file
		// n = fscanf(infile, "%Lf	%Lf	%Lf\n", &timestamp, &curvedata[0][points], &curvedata[1][points]);

		// End if no more data
		if (n <= 0)
			break;

		if (points++ == COUNT - 1)
		{
			////////////////////////// .ivs conversion ////////////////////////

			fwrite(&timestamp, sizeof(double), 1, ivs_outfile);
			create_curves_with_regression();
			fwrite(&allcurves[indexInAllCurves], sizeof(long double), NUMPOINTS, ivs_outfile);

			////////////////////////// .gnu conversion ////////////////////////
			for (int j = 0; j < NUMPOINTS; j++)
			{
				fprintf(gnu_outfile, "%.9lf	\t %.9Lf \t %.9Lf\n", timestamp, VOLTAGES[j], allcurves[indexInAllCurves][j]);
			}
			fprintf(gnu_outfile, "\n");

			// Prepare for next curve
			points = 0;
		}
	} //end while
} // end convert_data

////////////////////////////////////////////////////////
void sort(long double array[2][COUNT])
{
	for (int i = 1; i < COUNT; i++)
	{
		int j = i;
		while (j > 0 && array[0][j - 1] > array[0][j])
		{
			long double tempx = array[0][j - 1];
			long double tempy = array[1][j - 1];
			// x
			array[0][j - 1] = array[0][j];
			array[0][j] = tempx;
			// y
			array[1][j - 1] = array[1][j];
			array[1][j] = tempy;
			j = j - 1;
		}
	}
}
///////////////////////////////////////////////
bool polynomialfit(int obs, int degree, long double *dx, long double *dy, long double *store) /* n, p */
{
	gsl_multifit_linear_workspace *ws;
	gsl_matrix *cov, *X;
	gsl_vector *y, *c;
	double chisq;

	int i, j;

	X = gsl_matrix_alloc(obs, degree);
	y = gsl_vector_alloc(obs);
	c = gsl_vector_alloc(degree);
	cov = gsl_matrix_alloc(degree, degree);

	for (i = 0; i < obs; i++)
	{
		gsl_matrix_set(X, i, 0, 1.0);
		for (j = 0; j < degree; j++)
		{
			gsl_matrix_set(X, i, j, pow(dx[i], j));
		}
		gsl_vector_set(y, i, dy[i]);
	}

	ws = gsl_multifit_linear_alloc(obs, degree);
	gsl_multifit_linear(X, y, c, cov, &chisq, ws);

	/* store result ... */
	for (i = 0; i < degree; i++)
	{
		store[i] = gsl_vector_get(c, i);
	}

	gsl_multifit_linear_free(ws);
	gsl_vector_free(c);
	return true;
}

///////////////////////////////////////////////////////////
long double polycurve(long double voltage, long double *coeffs, int degree)
{
	long double ret = coeffs[1] * voltage + coeffs[0];
	int i;
	for (i = 2; i < degree; i++)
	{
		ret += coeffs[i] * gsl_pow_int(voltage, i);
	}
	return ret;
}

//////////////////////////////////////////////
long double clamp_current(long double current)
{
	return fmin(fmax(current, 0), 0.1f);
}

//////////////////////////////////////////////
void create_curves_with_regression(void)
{
	long double tox[3];
	long double toy[3];

	// Clear curve first to all zeros
	for (int j = 0; j < NUMPOINTS - 1; j++)
	{
		allcurves[indexInAllCurves][j] = 0;
	}

	// Sort curve data cloud on Voltage
	sort(curvedata);

	// Get bounds for polyline
	long double leftmostpoint = curvedata[0][0];
	long double rightmostpoint = curvedata[0][COUNT - 1];

	// Get poly regression of all points
	polynomialfit(COUNT, DEGREE, curvedata[0], curvedata[1], coeff);
	int lastIndex = 63;
	int firstIndex = 0;
	for (int j = 0; j < NUMPOINTS - 1; j++)
	{
		if (VOLTAGES[j] < leftmostpoint)
		{
			// Get the index where the regression starts in allcurves
			firstIndex = j + 1;
		}
		if (VOLTAGES[j] > leftmostpoint && VOLTAGES[j] < rightmostpoint)
		{
			allcurves[indexInAllCurves][j] = clamp_current(polycurve(VOLTAGES[j], coeff, DEGREE));
		}
		if (VOLTAGES[j] > rightmostpoint)
		{
			lastIndex = j;
			break;
		}
	}

	// Draw a line through left part past point cloud, using points already
	// in curve
	memcpy(tox, &VOLTAGES[firstIndex + 1], sizeof(long double) * 3);
	memcpy(toy, &allcurves[indexInAllCurves][firstIndex + 1], sizeof(long double) * 3);
	polynomialfit(3, 2, tox, toy, coeff);
	for (int j = 0; j < firstIndex; j++)
	{
		allcurves[indexInAllCurves][j] = clamp_current(polycurve(VOLTAGES[j], coeff, 2));
	}

	// Draw a line through right part past point cloud, using points already
	// in curve
	// 2-degree since it will most likely curve into zero
	memcpy(tox, &VOLTAGES[lastIndex - 3], sizeof(long double) * 3);
	memcpy(toy, &allcurves[indexInAllCurves][lastIndex - 3], sizeof(long double) * 3);
	polynomialfit(3, 2, tox, toy, coeff);

	// We only want a negative slope between two points, if not negative
	// then render it at zero height
	for (int j = lastIndex; j < NUMPOINTS - 1; j++)
	{
		if (coeff[1] < 0)
		{
			allcurves[indexInAllCurves][j] = clamp_current(polycurve(VOLTAGES[j], coeff, 2));
		}
		else
		{
			allcurves[indexInAllCurves][j] = 0;
		}
	}
} //end create_curves_with_regression()

//////////////////////////////////////////////
int main(int argc, char **argv) // Create Main Function For Bringing It All Together
{
	if (argc != 3)
	{
		fprintf(stderr, "This program generates GNU plot file.\n");
		fprintf(stderr, "	Usage:   ./plot_surface <rawpair_file_name> <gnu_file_name> \n");
		exit(0);
	}

	char output_img_file_name[255];

	strcpy(input_file_name, argv[1]);
	strcpy(gnu_file_name, argv[2]);
	strcpy(ivs_file_name, argv[2]);

	strcpy(output_img_file_name, gnu_file_name);
	strcat(output_img_file_name, "_render");

	strcat(gnu_file_name, ".gnu");
	strcat(ivs_file_name, ".ivs");

	printf("Saving IV-surface to %s...\n", ivs_file_name);

	infile = fopen(input_file_name, "r");
	gnu_outfile = fopen(gnu_file_name, "w");
	ivs_outfile = fopen(ivs_file_name, "w");

	fprintf(gnu_outfile, "set terminal png  transparent enhanced font \"arial,10\" fontscale 1.0 size 1600, 800\n");
	fprintf(gnu_outfile, "set output '%s.png'\n", output_img_file_name);
	fprintf(gnu_outfile, "unset border\n");
	fprintf(gnu_outfile, "set style fill   solid 1.00 noborder\n");
	fprintf(gnu_outfile, "set dummy u, v\n");
	fprintf(gnu_outfile, "unset key\n");
	fprintf(gnu_outfile, "set ticslevel 0\n");
	fprintf(gnu_outfile, "set view 45,85, 1.145, 1\n");
	fprintf(gnu_outfile, "set isosamples 75, 75\n");
	fprintf(gnu_outfile, "set ztics\n");
	fprintf(gnu_outfile, "set ylabel \"Time (s)\" \n");
	fprintf(gnu_outfile, "set xlabel \"Voltage (V)\" rotate parallel\n");
	fprintf(gnu_outfile, "set title \"\" \n");
	fprintf(gnu_outfile, "set urange [ -3.14159 : 3.14159 ] noreverse nowriteback\n");
	fprintf(gnu_outfile, "set vrange [ -3.14159 : 3.14159 ] noreverse nowriteback\n");
	fprintf(gnu_outfile, "set pm3d depthorder\n");
	fprintf(gnu_outfile, "set pm3d lighting primary 0.5 specular 0.6\n");
	fprintf(gnu_outfile, "set palette rgbformulae 8, 9, 7\n");
	fprintf(gnu_outfile, "splot \"-\" using 2:1:3 with pm3d\n");
	fprintf(gnu_outfile, "# Time, Voltage, Current\n");

	convert_data();

	fclose(infile);
	fclose(gnu_outfile);
	fclose(ivs_outfile);
	return 0;
}
